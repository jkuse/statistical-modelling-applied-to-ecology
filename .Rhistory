boxplot(dados)
beeswarm::beeswarm(dados, col="red", pch=16, method="swarm")
# boxplot
boxplot(dados)
# Podemos extrair os valores do boxplot com:
boxplot(dados)$stat
# Vamos usar dados do peso de galinhas e tipo de alimentacao
data(chickwts)
# Histogramas
hist(chickwts$weight)
# aumentamos o numero de classes com o argumento 'nclass'
hist(chickwts$weight, nclass=15)
hist(chickwts$weight, nclass=30)
# TambÃ©m podemos plotar o histograma classico com area = 1  (densidade de probabilidades)
hist(chickwts$weight, prob = T)
# Podemos adicionar os dados brutos no eixo x com a funcao 'rug'
hist(chickwts$weight, main="", col="gray", xlab="Peso das galinhas")
rug(chickwts$weight)
# Cleveland dotplot
dotchart(chickwts$weight) # weight no eixo x
plot(chickwts$weight)  # Compare com a funcao generica 'plot'
# Cleveland dotplot
dotchart(chickwts$weight) # weight no eixo x
plot(chickwts$weight)  # Compare com a funcao generica 'plot'
# Cleveland dotplot
dotchart(chickwts$weight) # weight no eixo x
plot(chickwts$weight)  # Compare com a funcao generica 'plot'
# Beeswarm
beeswarm::beeswarm(chickwts$weight)
# Densidade kernel
plot(density(chickwts$weight)) # Area abaixo da curva tambem soma 1
# Densidade kernel sobreposta com histograma
hist(chickwts$weight, prob = TRUE)
lines(density(chickwts$weight))
# Podemos verificar a distribuicao da variavel peso em um histograma
hist(chickwts$weight, prob = TRUE)
# Podemos gerar uma distribuicao normal teorica a partir da media e desvio padrao do peso observado
# Vamos sobrepor nossa distribuicao teorica com o histograma dos pesos observados
curve(dnorm(x, mean = mean(chickwts$weight), sd = sd(chickwts$weight)),
add=T, col="red")
# Grafico quantil-quantil - QQ-Plot
qqnorm(chickwts$weight)
qqline(chickwts$weight, col="blue", lwd=2)
# Grafico quantil-quantil na unha
quantile(chickwts$weight, probs=seq(0,1,0.01)) -> quant_sample
rnorm(1000, mean=mean(chickwts$weight), sd=sd(chickwts$weight)) -> random
quantile(random, probs=seq(0,1,0.01)) -> quant_theoretical
plot(quant_theoretical, quant_sample)
abline(0,1, col="red", lwd=2)
# QQ-plots com outras distribuicoes
if(!require(car)){install.packages("car");library(car)}
qqPlot(chickwts$weight)
qqPlot(chickwts$weight, distribution="pois", lambda=mean(chickwts$weight))
qqPlot(chickwts$weight)
qqPlot(chickwts$weight, distribution="pois", lambda=mean(chickwts$weight))
qqPlot(chickwts$weight, distribution="unif")
# Vamos usar dados sobre velocidade e distancia de parada de automoveis
data(cars)
# Plotando um diagrama de dispersao com a funcao generica 'plot'
plot(cars$speed, cars$dist)
plot(cars$dist ~ cars$speed) # Ou no formato de formula
# Diagrama de dispersao com linha de suavizacao
scatter.smooth(cars$dist ~ cars$speed,
ylab="Distancia de parada",
xlab="Velocidade")
# Ajustando o grau de suavizacao
scatter.smooth(cars$dist ~ cars$speed, span=0.1) # muito suavizado
scatter.smooth(cars$dist ~ cars$speed, span=0.5)
scatter.smooth(cars$dist ~ cars$speed, span=5) # pouco suavizado
# Vamos usar os dados da qualidade do ar de Nova Iorque
data(airquality)
# Boxplots condicionados
boxplot(airquality$Temp ~ airquality$Month)
boxplot(airquality$Temp ~ airquality$Month, varwidth = TRUE) # Veja no help o que o argumento 'varwidth' faz
?boxplot
# Boxplots condicionados
boxplot(airquality$Temp ~ airquality$Month)
boxplot(airquality$Temp ~ airquality$Month, varwidth = TRUE) # Veja no help o que o argumento 'varwidth' faz
# Boxplots condicionados
boxplot(airquality$Temp ~ airquality$Month)
boxplot(airquality$Temp ~ airquality$Month, varwidth = TRUE) # Veja no help o que o argumento 'varwidth' faz
# Boxplot com notch
boxplot(airquality$Temp ~ airquality$Month, notch = TRUE)
?boxplot
# Boxplot com notch
boxplot(airquality$Temp ~ airquality$Month, notch = TRUE)
boxplot(airquality$Temp ~ airquality$Month, varwidth = TRUE) # Veja no help o que o argumento 'varwidth' faz
# Boxplot com notch
boxplot(airquality$Temp ~ airquality$Month, notch = TRUE)
# Diagramas de dispersao condicionados
coplot(Ozone ~ Temp | Month, data=airquality)
# Ou com a funcao do pacote 'lattice'
require(lattice)
xyplot(Ozone ~ Temp | Month, data=airquality)
xyplot(Ozone ~ Temp | Month,
data=airquality, type = c("p", "r")) # com linha de regressao
xyplot(Ozone ~ Temp | Month,
data=airquality, type = c("p", "smooth")) # com linha de suavizacao
data(Mandel)
?Mandel
# Pairplot
pairs(Mandel)
# Funcao encontrada no help da funcao 'pairs' para plotar histogramas
panel.hist <- function(x, ...)
{
usr <- par("usr"); on.exit(par(usr))
par(usr = c(usr[1:2], 0, 1.5) )
h <- hist(x, plot = FALSE)
breaks <- h$breaks; nB <- length(breaks)
y <- h$counts; y <- y/max(y)
rect(breaks[-nB], 0, breaks[-1], y, col="cyan", ...)
}
# Agora plotamos com histograma nos paineis diagonais
pairs(Mandel, diag.panel=panel.hist)
# Outra funcao para fornecer os coeficientes de correlacao
# com a fonte proporcional ao indice
panel.cor <- function(x, y, digits=2, prefix="", cex.cor, ...)
{
usr <- par("usr"); on.exit(par(usr))
par(usr = c(0, 1, 0, 1))
r <- abs(cor(x, y))
txt <- format(c(r, 0.123456789), digits=digits)[1]
txt <- paste(prefix, txt, sep="")
if(missing(cex.cor)) cex.cor <- 0.8/strwidth(txt)
text(0.5, 0.5, txt, cex = cex.cor * r)
}
# Agora plotamos com indices de correlacao e histogramas
pairs(Mandel, diag.panel=panel.hist, lower.panel=panel.cor)
# Incluimos tambem a linha de suavizacao
pairs(Mandel, panel=panel.smooth, diag.panel=panel.hist, lower.panel=panel.cor)
# Utilize o banco de dados 'anscombe'
data(anscombe)
help(anscombe)
anscombe
# Ajuste uma regressao linear a cada par de colunas y1~x1, y2~x2...
lm1 <- with(anscombe, lm(y1 ~ x1))
ff <- y ~ x
mods <- setNames(as.list(1:4), paste0("lm", 1:4))
for(i in 1:4) {
ff[2:3] <- lapply(paste0(c("y","x"), i), as.name)
## or   ff[[2]] <- as.name(paste0("y", i))
##      ff[[3]] <- as.name(paste0("x", i))
mods[[i]] <- lmi <- lm(ff, data = anscombe)
print(anova(lmi))
}
mods
View(Mandel)
View(anscombe)
mods <- setNames(as.list(1:4), paste0("lm", 1:4))
for(i in 1:4) {
ff[2:3] <- lapply(paste0(c("y","x"), i), as.name)
lm(ff)
}
lm2 <- with(anscombe, lm(y2 ~ x2))
lm3 <- with(anscombe, lm(y3 ~ x3))
lm4 <- with(anscombe, lm(y4 ~ x4))
# Ajuste uma regressao linear a cada par de colunas y1~x1, y2~x2...
lm1 <- with(anscombe, lm(y1 ~ x1))
lm2 <- with(anscombe, lm(y2 ~ x2))
lm3 <- with(anscombe, lm(y3 ~ x3))
lm4 <- with(anscombe, lm(y4 ~ x4))
# Compare os valores estimados de interceptos e inclinacao da reta
coef(lm1)
lms <- list(lm1,lm2,lm3,lm4)
for (i in lms) {
coef_val <- as.list(coef(i))
}
coef_val
View(chickwts)
View(chickwts)
View(coef_val)
coef_val <- as.list(coef[i])
coef_val <- as.list(coef(i))
coef_val
coef(lm2)
coef(lm3)
coef(lm4)
# Compare os valores estimados de interceptos e inclinacao da reta
coef(lm1)
coef(lm2)
coef(lm3)
coef(lm4)
# Compare as medias e desvios padrao de cada variavel
apply(anscombe,2,mean)
apply(anscombe,2,sd)
# Agora plote cada par de variaveis
lm1
# Agora plote cada par de variaveis
plot(lm1)
par(mfrow = c(2,2))
plot(lm1)
plot(lm2)
plot(lm1)
plot(lm3)
plot(lm4)
lm4 <- with(anscombe, lm(y4 ~ x4))
plot(lm1)
plot(lm2)
plot(lm3)
plot(lm4)
# Vamos usar um banco de dados usado por Fisher (1936)
# Sao medidas florais de tres especies
data(iris)
help(iris)
View(iris)
# Como eh a distribuicao das medidas de cada variavel?
head(iris)
as.list(iris$Sepal.Length, iris$Sepal.Width, iris$Petal.Length, iris$Petal.Width)
variables <- as.list(iris$Sepal.Length, iris$Sepal.Width, iris$Petal.Length, iris$Petal.Width)
View(variables)
variables <- as.vector(iris$Sepal.Length, iris$Sepal.Width, iris$Petal.Length, iris$Petal.Width)
# Como eh a distribuicao das medidas de cada variavel?
head(iris)
hist(iris$Sepal.Length)
hist(iris$Sepal.Width)
hist(iris$Petal.Length)
hist(iris$Petal.Width)
abline(0,1, col="red", lwd=2)
# Como eh a distribuicao das medidas de cada variavel?
head(iris)
hist(iris$Sepal.Length)
hist(iris$Sepal.Width)
hist(iris$Petal.Length)
hist(iris$Petal.Width)
par(mfrow = c(1,1))
plot(iris$Sepal.Length)
plot(table(dados))
# Visualizando os dados brutos
plot(dados)
# Outras formas de identificar outliers
dotchart(dados) # Mostra os dados sequencialmente (ordem) de baixo pra cima no eixo y
plot(M1)
pairs(iris$Sepal.Length)
qqplot(iris$Sepal.Length)
qqnorm(iris$Sepal.Length)
qqline(iris$Sepal.Length, col="blue", lwd=2)
qqnorm(iris$Sepal.Widht)
qqline(iris$Sepal.Width, col="blue", lwd=2)
qqnorm(iris$Sepal.Widht)
qqnorm(iris$Sepal.Width)
qqline(iris$Sepal.Width, col="blue", lwd=2)
qqnorm(iris$Sepal.Length)
qqline(iris$Sepal.Length, col="blue", lwd=2)
qqnorm(iris$Sepal.Width)
qqline(iris$Sepal.Width, col="blue", lwd=2)
par(mforw = c(2,2))
par(mfrow = c(2,2))
qqnorm(iris$Sepal.Length)
qqline(iris$Sepal.Length, col="blue", lwd=2)
qqnorm(iris$Sepal.Width)
qqline(iris$Sepal.Width, col="blue", lwd=2)
qqnorm(iris$Petal.Width)
qqline(iris$Petal.Width, col="blue", lwd=2)
qqnorm(iris$Petal.Length)
qqline(iris$Petal.Length, col="blue", lwd=2)
par(mfrow = c(1,1))
?qqnorm
par(mfrow = c(2,2))
qqnorm(iris$Sepal.Length, main= "Sepal Length")
qqline(iris$Sepal.Length, col="blue", lwd=2)
qqnorm(iris$Sepal.Width, main = "Sepal Width")
qqline(iris$Sepal.Width, col="blue", lwd=2)
qqnorm(iris$Petal.Width, main = "Petal Width")
qqline(iris$Petal.Width, col="blue", lwd=2)
qqnorm(iris$Petal.Length, main = "Petal Length")
qqline(iris$Petal.Length, col="blue", lwd=2)
qqnorm(iris$Sepal.Length, main= "Sepal Length")
qqline(iris$Sepal.Length, col="blue", lwd=2)
qqnorm(iris$Sepal.Width, main = "Sepal Width")
qqline(iris$Sepal.Width, col="blue", lwd=2)
qqnorm(iris$Petal.Length, main = "Petal Length")
qqline(iris$Petal.Length, col="blue", lwd=2)
qqnorm(iris$Petal.Width, main = "Petal Width")
qqline(iris$Petal.Width, col="blue", lwd=2)
# Vamos usar novamente os dados de velocidade e distancia de parada
data(cars)
str(cars)
help(cars)
# Vamos ajustar um modelo linear aos dados
# Queremos prever a distacia de parada atraves da velocidade
lm(dist ~ speed, data=cars) -> reg.cars
# Vamos ver os resultados da analise
coef(reg.cars) # Podemos obter os coeficientes/betas estimados
confint(reg.cars) # Intervalo de confianca dos coeficientes
?coef
# Vamos obter os resultados completos da analise com a funcao generica 'summary'
summary(reg.cars)
# Vamos olhar para a tabela com os coeficientes:
# Se dividirmos o valor estimado do coeficiente pelo seu erro padrao,
# obteremos o valor da estatistica t (da distribuicao t de Student) - a coluna
# 't value' da tabela
# Vamos tentar para a inclinacao:
3.9324/0.4155
# Esperamos que o valor estimado do coeficiente dividido pelo seu erro padrao
# siga uma distribuicao t com n-2 graus de liberdade
# Podemos calcular facilmente a probabilidade de obter um valor igual ou maior
# que este usando a funcao 'pt' com o argumento 'lower.tail=FALSE'
# Multiplicamos a probabilidade por dois porque a reta pode ser tanto positiva
# quanto negativa (teste bi-caudal)
2 * pt(9.46426, 48, lower.tail=FALSE)
# Vamos plotar em um grafico as duas variaveis e o que o modelo preve da relacao
# linear entre as duas
plot(dist ~ speed, data=cars)
abline(reg.cars, col="blue")
# Nem todos os pontos caem em cima da linha, ou seja, existe um ruido nos dados
# que o modelo nao preve. A diferenca entre o que o modelo preve e os dados
# chama-se desvios ou erros residuais
# Obtemos estes erros atraves da funcao 'resid'
resid(reg.cars)
# Vamos plotar os erros residuais pelos valores preditos
plot(resid(reg.cars) ~ fitted(reg.cars))
abline(h=0, lty=2)
# Vamos plotar os erros residuais pelos valores preditos
### which means residuals vs fitted
plot(resid(reg.cars) ~ fitted(reg.cars))
abline(h=0, lty=2)
# Mas seria melhor observar os residuos standardizados:
plot(rstandard(reg.cars) ~ fitted(reg.cars), ylab="Residuos standardizados",
xlab="Valores preditos")
abline(h=0, lty=2)
# Melhor ainda sao os residuos studentizados
plot(rstudent(reg.cars) ~ fitted(reg.cars))
abline(h=0, lty=2)
# Podemos explorar mais os erros residuais
# Vamos ver se eles tem media zero
summary(rstudent(reg.cars))
??rstudent
?rstudent
# E a distribuicao normal?
hist(rstudent(reg.cars)) # Parece que sim, mas tem muito ruido em uma das caudas
# Outro grafico diagnostico
qqnorm(rstudent(reg.cars))
qqline(rstudent(reg.cars), col="red")
# Podemos checar a qualidade das previsoes do modelo pelo r quadrado
# Calculamos o r quadrado na unha
(cor(cars$dist,fitted(reg.cars)))^2 # Mas sempre melhor usar o r quadrado ajustado
summary(reg.cars)
# Plotando os preditos pelo valores de y tambem vemos a qualidade da predicao
plot(fitted(reg.cars), cars$dist, ylab="Distancia de parada",
xlab="Valores preditos de y pelo modelo")
abline(0,1, col="red") # Esta eh a linha da predicao perfeita
# Outra forma de verificar qualidade do ajuste
# Plotando residuos pelos valores preditos
scatter.smooth(resid(reg.cars) ~ fitted(reg.cars))
abline(h=0, col="red")
# Vamos ver se existem observacoes influentes
influence.measures(reg.cars) # Veja as marcadas com asterisco
# Outra forma de ver observacoes influentes
plot(cooks.distance(reg.cars), ylab="Distancia de Cook", las=1)
# Vamos ver se existem observacoes influentes
influence.measures(reg.cars) # Veja as marcadas com asterisco
# Outra forma de ver observacoes influentes
plot(cooks.distance(reg.cars), ylab="Distancia de Cook", las=1)
# Quatro graficos diagnosticos do modelo de forma facil e rapida
plot(reg.cars) # aperte o Enter para aparecer os plots
# Outra forma de ver observacoes influentes
plot(cooks.distance(reg.cars), ylab="Distancia de Cook", las=1)
# Se eu quiser prever qual a distancia de parada a uma velocidade de 30 mph
-17.579+(3.9324*30)
# Quatro graficos diagnosticos do modelo de forma facil e rapida
plot(reg.cars) # aperte o Enter para aparecer os plots
plot(reg.cars) # aperte o Enter para aparecer os plots
new <- data.frame(speed = 30)
predict(reg.cars, new)
# Se eu quiser prever qual a distancia de parada a uma velocidade de 30 mph
-17.579+(3.9324*30)
# Quatro graficos diagnosticos do modelo de forma facil e rapida
plot(reg.cars) # aperte o Enter para aparecer os plots
# Se eu quiser prever qual a distancia de parada a uma velocidade de 30 mph
-17.579+(3.9324*30)
coef(reg.cars)[1]+coef(reg.cars)[2]*30
coef(reg.cars)[1]+coef(reg.cars)[2]*30
# ou...
new <- data.frame(speed = 30)
predict(reg.cars, new)
# Agora quero prever com outro valor
new <- data.frame(speed = 2)
predict(reg.cars, new)  # Ops! O valor previsto foi negativo.
# Dados de concentracao de dioxido de carbono medida no topo do vulcao Mauna Loa
data(co2)
# Vamos plotar
plot(co2)
# Exploramos o objeto com os dados
co2
str(co2)
class(co2)  # Da classe 'time series', temos que manipular os dados pra
# Transformamos o objeto em um data-frame
data.frame(co2) -> co2.df
# Criamos duas novas variaveis (colunas) com os anos e os meses
rep(1:12, 39) -> co2.df$Mes
View(co2.df)
rep(1959:1997, each=12) -> co2.df$Ano
# Conferindo o novo data-frame
str(co2.df)
# Agora sim! Podemos ajustar o modelo...
lm(co2 ~ Ano, data=co2.df) -> lm.co2
# Interprete os resultados do modelo
summary(lm.co2)
# Vamos plotar os dados e a reta de regressao
with(co2.df, plot(Ano, co2))
abline(lm.co2, col="red", lwd=2)
?with
# Vamos plotar os dados e a reta de regressao
with(co2.df, plot(Ano, co2))
abline(lm.co2, col="red", lwd=2)
# Valide o modelo
plot(lm.co2)
plot(lm.co2)
par(mfrow = c(2,2))
plot(lm.co2)
par(mfrow = c(1,1))
dev.off()
# Valide o modelo
par(mfrow = c(2,2))
plot(lm.co2)
par(mfrow = c(1,1))
# Vamos plotar os residuos do modelo pelo mes
plot(co2.df$Mes, resid(lm.co2))
# Vamos plotar os residuos do modelo pelo mes
plot(co2.df$Mes, resid(lm.co2))
# Podemos melhorar o modelo
# Existe uma variacao mensal. Vamos explorar um pouco mais...
boxplot(co2.df$co2 ~ co2.df$Mes)
plot(tapply(co2.df$co2, co2.df$Mes, mean))
# Podemos melhorar o modelo
# Existe uma variacao mensal. Vamos explorar um pouco mais...
boxplot(co2.df$co2 ~ co2.df$Mes)
plot(tapply(co2.df$co2, co2.df$Mes, mean))
# Podemos ajustar um modelo aditivo com ano e mes como variavel categorica
# Ou seja, cada mes tera um efeito proprio
lm(co2 ~ Ano + as.factor(Mes), data=co2.df) -> lm.co2.ad
summary(lm.co2.ad)
plot(lm.co2.ad)
# O que este modelo preve?
if(!require(effects)){install.packages("effects");library(effects)} ## explore tambem o pacote sjPlot
# O que este modelo preve?
if(!require(effects)){install.packages("effects");library(effects)} ## explore tambem o pacote sjPlot
plot(allEffects(lm.co2.quad))
# Agora vamos ajustar um modelo com efeito quadratico no mes
lm(co2 ~ Ano + Mes + I(Mes^2), data=co2.df) -> lm.co2.quad
summary(lm.co2.quad)
plot(lm.co2.quad)
AIC(lm.co2, lm.co2.ad, lm.co2.quad)
# O que este modelo preve?
if(!require(effects)){install.packages("effects");library(effects)} ## explore tambem o pacote sjPlot
plot(allEffects(lm.co2.quad))
# Qual foi o melhor modelo?
AIC(lm.co2, lm.co2.ad, lm.co2.quad)
# Os dados sao independentes?
acf(co2)  # Uau!!! Altamente correlacionados...
# Outro grafico diagnostico
qqnorm(rstudent(reg.cars))
qqline(rstudent(reg.cars), col="red")
# 3.1 Tendencia da populacao norte americana
data(uspop)
str(uspop)
summary(uspop)
head(uspop)
hist(uspop)
?hist
hist(uspop, nclass = 50 )
hist(uspop, nclass = 20 )
hist(uspop, nclass = 15 )
hist(uspop, nclass = 15 )
hist(uspop, nclass = 10)
?uspop
plot(uspop, log = "y", main = "uspop data", xlab = "Year",
ylab = "U.S. Population (millions)")
qqnorm(uspop)
qqline(uspop)
# Exploramos o objeto com os dados
co2
str(co2)
class(co2)  # Da classe 'time series', temos que manipular os dados pra
# Transformamos o objeto em um data-frame
data.frame(co2) -> co2.df
# Criamos duas novas variaveis (colunas) com os anos e os meses
rep(1:12, 39) -> co2.df$Mes
rep(1959:1997, each=12) -> co2.df$Ano
# Conferindo o novo data-frame
str(co2.df)
# Agora sim! Podemos ajustar o modelo...
lm(co2 ~ Ano, data=co2.df) -> lm.co2
# Interprete os resultados do modelo
summary(lm.co2)
# Vamos plotar os dados e a reta de regressao
with(co2.df, plot(Ano, co2))
abline(lm.co2, col="red", lwd=2)
# Valide o modelo
par(mfrow = c(2,2))
plot(lm.co2)
par(mfrow = c(1,1))
# Vamos plotar os residuos do modelo pelo mes
plot(co2.df$Mes, resid(lm.co2))
# Podemos melhorar o modelo
# Existe uma variacao mensal. Vamos explorar um pouco mais...
boxplot(co2.df$co2 ~ co2.df$Mes)
plot(tapply(co2.df$co2, co2.df$Mes, mean))
# Podemos ajustar um modelo aditivo com ano e mes como variavel categorica
# Ou seja, cada mes tera um efeito proprio
lm(co2 ~ Ano + as.factor(Mes), data=co2.df) -> lm.co2.ad
summary(lm.co2.ad)
plot(lm.co2.ad)
# Agora vamos ajustar um modelo com efeito quadratico no mes
lm(co2 ~ Ano + Mes + I(Mes^2), data=co2.df) -> lm.co2.quad
plot(lm.co2.ad)
# O que este modelo preve?
if(!require(effects)){install.packages("effects");library(effects)} ## explore tambem o pacote sjPlot
plot(allEffects(lm.co2.quad))
# Qual foi o melhor modelo?
AIC(lm.co2, lm.co2.ad, lm.co2.quad)
dados <- read.table("UD8_arbustos_cresc.tsv", header=T, dec='.', fill=T) # row.names=1,  meusdados.txt
