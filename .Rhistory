qqPlot(RK$TOT.N, distribution = "poiss", lambda = mean(RK$TOT.N))
qqPlot(RK$TOT.N, distribution = "pois", lambda = mean(RK$TOT.N))
hist(RK$TOT.N)
qqPlot(RK$TOT.N, distribution = "pois", lambda = mean(RK$TOT.N))
summary(M1)
pseudoR1 <- ((1071.4 - 390.9)/1071.4)*100
pseudoR1 <- ((1071.4 - 390.9)/1071.4)*100
pseudoR1
summary(M2)
?qqPlot
qqPlot(RK$TOT.N, distribution = "negative binomial")
qqPlot(RK$TOT.N, distribution = "qnegative binomial")
qqPlot(RK$TOT.N, distribution = "qqnegative binomial")
vif(M2) # Tudo ok!!! VIF precisa ser menor que 3
qqPlot(RK$TOT.N, distribution = "qqnegative binomial")
vif(M2) # Tudo ok!!! VIF precisa ser menor que 3
vif(M2) # Tudo ok!!! VIF precisa ser menor que 3
cor(M2)
cor(M2)
cor(M1)
vars <- RK[,-1]
cor(vars)
# Um comando que automatiza a selecao pelo AIC
step(M2) # definir forward ou backward ou both (ver help da funcao)
# Comando drop1
drop1(M2, test="Chi")
drop1(M2, test="Chi") # vamos retirar SQ.DWATCOUR pois eh a que menos aumenta o Deviance
M3<-glm(TOT.N~OPEN.L+MONT.S+SQ.POLIC+
SQ.SHRUB+SQ.WATRES+L.WAT.C+SQ.LPROAD+
D.PARK,family=poisson,data=RK)
summary(M3)
drop1(M3, test="Chi") # vamos retirar OPEN.L pois eh a que menos aumenta o Deviance
M4 <-glm(TOT.N~MONT.S+SQ.POLIC+
SQ.SHRUB+SQ.WATRES+L.WAT.C+SQ.LPROAD+
D.PARK,family=poisson,data=RK)
summary(M4)
summary(M4)
drop1(M4, test="Chi") # vamos retirar SQ.WATRES pois eh a que menos aumenta o Deviance
summary(M5)
drop1(M5, test="Chi") # vamos retirar SQ.LPROAD pois eh a que menos aumenta o Deviance
M6 <- glm(TOT.N~MONT.S+SQ.POLIC+
SQ.SHRUB+L.WAT.C+
D.PARK,family=poisson,data=RK)
drop1(M6, test="Chi")
?dredge # aos curiosos (e preguicosos) explore a funcao dredge... bem legal... mas cuidado com automatizacoes...
model.sel(M1, M2, M3, M4, M5, M6)
if(!require(AICcmodavg)){install.packages("AICcmodavg");library(AICcmodavg)} # Instalando pacotes requeridos
ModCandidatos<-list()
ModCandidatos[[1]]<-M1
ModCandidatos[[2]]<-M2
ModCandidatos[[3]]<-M3
ModCandidatos[[4]]<-M4
ModCandidatos[[5]]<-M5
ModCandidatos[[6]]<-M6
Modnames <- paste("Mod", 1:length(ModCandidatos), sep = " ")
res.table <- aictab(cand.set = ModCandidatos, modnames = Modnames,
second.ord = FALSE, c.hat = 4) # o c-hat eh o parametro de sobredispercao
res.table # Legal... vc pode usar essa opcao para incluir dispercao no AIC (existem criticas ao QuasiAIC)
res.table # Veja que o output apresenta um quasiAIC e não o AIC
if(!require(bbmle)){install.packages("bbmle");library(bbmle)}
AIC <- ICtab (M1, M2, M3, M4, M5, M6, base = TRUE, type = c("AICc"), weights = TRUE,
delta = TRUE, sort = TRUE, nobs = 52, k = TRUE)
AIC
res.table # Veja que o output apresenta um quasiAIC e não o AIC
res.table <- aictab(cand.set = ModCandidatos, modnames = Modnames,
second.ord = FALSE, c.hat = 1) # se nao quiser incluir dispercao, c-hat = 1
res.table # Veja que o output apresenta um quasiAIC e não o AIC
# Rever output do M2
summary(M2)
# Dividir o desvio residual pelos graus de liberdade estima a sobredispersao
270.23/42
Mquasi1<- glm(TOT.N ~ OPEN.L + MONT.S + SQ.POLIC +
SQ.SHRUB + SQ.WATRES + L.WAT.C + SQ.LPROAD+
SQ.DWATCOUR + D.PARK, family = quasipoisson, data = RK)
summary(Mquasi1)
Mquasi1<- glm(TOT.N ~ OPEN.L + MONT.S + SQ.POLIC +
SQ.SHRUB + SQ.WATRES + L.WAT.C + SQ.LPROAD+
SQ.DWATCOUR + D.PARK, family = quasipoisson, data = RK)
summary(Mquasi1)
drop1(Mquasi1,test="F") # SQ.DWATCOUR eh a que menos aumenta os residuos, bora tira-la
Mquasi2<- glm(TOT.N ~ OPEN.L + MONT.S + SQ.POLIC+
SQ.SHRUB + SQ.WATRES + L.WAT.C + SQ.LPROAD+
D.PARK, family = quasipoisson, data = RK)
summary(Mquasi2)
drop1(Mquasi2, test = "F")
Mquasi3<- glm(TOT.N ~ + MONT.S + SQ.POLIC+
SQ.SHRUB + SQ.WATRES + L.WAT.C + SQ.LPROAD+
D.PARK, family = quasipoisson, data = RK)
Mquasi3<- glm(TOT.N ~ MONT.S + SQ.POLIC+
SQ.SHRUB + SQ.WATRES + L.WAT.C + SQ.LPROAD+
D.PARK, family = quasipoisson, data = RK)
summary(Mquasi3)
summary(Mquasi2)
drop1(Mquasi3, test="F")
Mquasi4<- glm(TOT.N ~ MONT.S + SQ.POLIC+
SQ.SHRUB + L.WAT.C + SQ.LPROAD+
D.PARK, family = quasipoisson, data = RK)
summary(Mquasi4)
drop1(Mquasi4)
drop1(Mquasi4)
drop1(Mquasi4, test = "F")
Mquasi5<- glm(TOT.N ~ MONT.S + SQ.POLIC+
SQ.SHRUB + L.WAT.C +
D.PARK, family = quasipoisson, data = RK)
summary(Mquasi5)
drop1(Mquasi5)
drop1(Mquasi5, test="F")
Mquasi6<- glm(TOT.N ~ MONT.S + SQ.POLIC + L.WAT.C +
D.PARK, family = quasipoisson, data = RK)
summary(Mquasi6)
drop1(Mquasi6)
drop1(Mquasi6, test="F")
Mquasi6<- glm(TOT.N ~ MONT.S + L.WAT.C +
D.PARK, family = quasipoisson, data = RK)
summary(Mquasi6)
summary(Mquasi5)
Mquasi6<- glm(TOT.N ~ MONT.S + SQ.POLIC + L.WAT.C +
D.PARK, family = quasipoisson, data = RK)
Mquasi7<- glm(TOT.N ~ MONT.S + L.WAT.C +
D.PARK, family = quasipoisson, data = RK)
summary(Mquasi7)
summary(Mquasi6)
summary(Mquasi7)
drop1(Mquasi7, test='F')
Mquasi8 <-  glm(TOT.N ~ L.WAT.C +
D.PARK, family = quasipoisson, data = RK)
summary(Mquasi8)
drop1(mquasi8)
drop1(Mquasi8)
drop1(Mquasi8, test = "F")
Mquasi9 <-  glm(TOT.N ~
D.PARK, family = quasipoisson, data = RK)
summary(Mquasi9)
summary(Mquasi2)
Mquasi1<- glm(TOT.N ~ OPEN.L + MONT.S + SQ.POLIC +
SQ.SHRUB + SQ.WATRES + L.WAT.C + SQ.LPROAD+
SQ.DWATCOUR + D.PARK, family = quasipoisson, data = RK)
Mquasi1<- glm(TOT.N ~ OPEN.L + MONT.S + SQ.POLIC +
SQ.SHRUB + SQ.WATRES + L.WAT.C + SQ.LPROAD+
SQ.DWATCOUR + D.PARK, family = quasipoisson, data = RK)
summary(Mquasi1)
Mquasi2<- glm(TOT.N ~ OPEN.L + MONT.S + SQ.POLIC+
SQ.SHRUB + SQ.WATRES + L.WAT.C + SQ.LPROAD+
D.PARK, family = quasipoisson, data = RK)
summary(Mquasi1)
summary(Mquasi2)
summary(Mquasi3)
res.table <- aictab(cand.set = ModCandidatos, modnames = Modnames,
second.ord = FALSE, c.hat = 4) # o c-hat eh o parametro de sobredispercao
res.table # Legal... vc pode usar essa opcao para incluir dispercao no AIC (existem criticas ao QuasiAIC)
res.table <- aictab(cand.set = ModCandidatos, modnames = Modnames,
second.ord = FALSE, c.hat = 1) # se nao quiser incluir dispercao, c-hat = 1
res.table # Veja que o output apresenta um quasiAIC e não o AIC
# Validacao para quasipoisson
M1quasi<- glm(TOT.N ~ D.PARK, family = quasipoisson, data = RK)
plot(M1quasi)
par(mfrow = c(2,2))
par(mfrow = c(1,1))
# Validacao para quasipoisson
M1quasi<- glm(TOT.N ~ D.PARK, family = quasipoisson, data = RK)
par(mfrow = c(2,2))
plot(M1quasi)
summary(Mquasi9)
drop1(Mquasi8, test = "F")
Mquasi1<- glm(TOT.N ~ OPEN.L + MONT.S + SQ.POLIC +
SQ.SHRUB + SQ.WATRES + L.WAT.C + SQ.LPROAD+
SQ.DWATCOUR + D.PARK, family = quasipoisson, data = RK)
summary(Mquasi1)
res.table <- aictab(cand.set = ModCandidatos, modnames = Modnames,
second.ord = FALSE, c.hat = 6) # o c-hat eh o parametro de sobredispercao
qqPlot(RK$TOT.N, distribution = "pois", lambda = mean(RK$TOT.N))
par(mfrow = c(1,1))
qqPlot(RK$TOT.N, distribution = "pois", lambda = mean(RK$TOT.N))
qqPlot(RK$TOT.N, distribution = "binomm", lambda = mean(RK$TOT.N))
?qqPlot
qqPlot(RK$TOT.N, distribution = "nbinom", lambda = mean(RK$TOT.N))
qqPlot(RK$TOT.N, distribution = "nbinom", lambda = mean(RK$TOT.N))
qqPlot(RK$TOT.N, distribution = "nbinom")
qqPlot(RK$TOT.N, distribution = "nbinom", lambda = mean(RK$TOT.N))
qqPlot(RK$TOT.N, distribution = "pois", lambda = mean(RK$TOT.N))
qqPlot(RK$TOT.N, distribution = "nbinom", lambda = mean(RK$TOT.N))
# O comando plot sintetiza o processo de validacao com quatro graficos (ver aula 3)
# Por exemplo, considerando o modelo M1
M1<-glm(TOT.N~D.PARK,family=poisson,data=RK)
par(mfrow=c(2,2))
plot(M1)
# Validacao para quasipoisson
M1quasi<- glm(TOT.N ~ D.PARK, family = quasipoisson, data = RK)
plot(M1quasi)
# Validacao para quasipoisson
M1quasi<- glm(TOT.N ~ D.PARK, family = quasipoisson, data = RK)
plot(M1quasi)
plot(M1)
plot(M1quasi)
# Esta funcao plot apresenta apenas o residuo ordinario
# Tenho outros residuos para GLM e posso (e devo) considera-lo na minha validacao
# Apenas observe o codigo abaixo
M1<-glm(TOT.N~D.PARK,family=quasipoisson,data=RK)
EP=resid(M1,type="pearson") # residual de pearson do M1
ED=resid(M1,type="deviance") # residual de desvio do M1
mu=predict(M1,type="response") # valores preditos
E=RK$TOT.N-mu # residual resposta (ordinario) do M1 (y-u)
EP2=E/sqrt(7.630148*mu) # o residual de pearson precisa ser dividido pela raiz quadrada da dispersao
par(mfrow=c(2,2))
plot(x=mu,y=E,main="Response residuals") # residuos pelos valores ajustados
plot(x=mu,y=EP,main="Pearson residuals")
plot(x=mu,y=EP2,main="Pearson residuals scaled")
plot(x=mu,y=ED,main="Deviance residuals")
par(mfrow=c(1,1))
# DICA: Use ao menos o plot dos desvios residuais pelos valores preditos (principal ferramenta de validacao)
ED=resid(M1,type="deviance") # residual de desvio do M1
mu=predict(M1,type="response") # valores preditos
plot(x=mu,y=ED,main="Deviance residuals") # Temos estrelas no ceu?
# Aos curiosos, explore o pacote DHARMa, para diagnostico dos residuos (https://cran.r-project.org/web/packages/DHARMa/vignettes/DHARMa.html)
# DHARMa: simula residuos standardizados que podem ser interpretados como em uma regressao normal
# 1. Simula novos dados observados a partir do modelo ajustado.
# 2. Calcula a função de densidade acumulada dos dados simulados e usa como probabilidades dos dados observados
# 3. Utiliza essa funçao baseada nos dados simulados para calcular novos resíduos
if(!require(DHARMa)){install.packages('DHARMa')};library(DHARMa)
# Voltando ao modelo M6
M6 <- glm(TOT.N~MONT.S+SQ.POLIC+
SQ.SHRUB+L.WAT.C+
D.PARK,family=poisson,data=RK)
# Calcular os residuos
simulationOutput <- simulateResiduals(fittedModel = M6, n = 1000)
residuals(simulationOutput)
# Testando dispersao
testDispersion(simulationOutput, type = "PearsonChisq")
# Plot principal para usar
plot(simulationOutput)
# Para o item 3, gosto muito do pacote sjPlot
if(!require(sjPlot)){install.packages("sjPlot");library(sjPlot)}
if(!require(ggplot2)){install.packages("ggplot2");library(ggplot2)}
if(!require(ggpubr)){install.packages("ggpubr");library(ggpubr)}
# Com ele podemos visualizar os efeitos de cada variável
M6 <- glm(TOT.N~MONT.S+SQ.POLIC+
SQ.SHRUB+L.WAT.C+
D.PARK,family=poisson,data=RK)
(effects.D.PARK <- plot_model(M6,
type = "eff",
show.legend = FALSE,
title = "",
axis.title = c("D.PARK", "TOT.N"),
term = c("D.PARK")))
(effects.SQ.SHRUB <- plot_model(M6,
type = "eff",
show.legend = FALSE,
title = "",
axis.title = c("SQ.SHRUB", "TOT.N"),
term = c("SQ.SHRUB")))
par(mfrow = c(2,2))
(effects.D.PARK <- plot_model(M6,
type = "eff",
show.legend = FALSE,
title = "",
axis.title = c("D.PARK", "TOT.N"),
term = c("D.PARK")))
(effects.SQ.SHRUB <- plot_model(M6,
type = "eff",
show.legend = FALSE,
title = "",
axis.title = c("SQ.SHRUB", "TOT.N"),
term = c("SQ.SHRUB")))
par(mfrow = c(2,2))
(effects.D.PARK <- plot_model(M6,
type = "eff",
show.legend = FALSE,
title = "",
axis.title = c("D.PARK", "TOT.N"),
term = c("D.PARK")))
(effects.SQ.SHRUB <- plot_model(M6,
type = "eff",
show.legend = FALSE,
title = "",
axis.title = c("SQ.SHRUB", "TOT.N"),
term = c("SQ.SHRUB")))
(effects.MONT.S <- plot_model(M6,
type = "eff",
show.legend = FALSE,
title = "",
axis.title = c("MONT.S", "TOT.N"),
term = c("MONT.S")))
(Fig1.Predicts <- ggarrange(effects.D.PARK, effects.SQ.SHRUB, effects.MONT.S,
labels = c("(a)", "(b)", "(c)"),
ncol = 3, nrow = 1, font.label = list(size = 9, color ="black")))
M.exemplo <- glm(TOT.N~MONT.S*D.PARK,family=poisson,data=RK)
(effects.M.exemplo <- plot_model(M.exemplo,
type = "eff",
show.legend = TRUE,
title = "",
axis.title = c("MONT.S", "TOT.N"),
term = c("D.PARK", "MONT.S")))
M.exemplo <- glm(TOT.N~MONT.S*D.PARK,family=poisson,data=RK)
(effects.M.exemplo <- plot_model(M.exemplo,
type = "eff",
show.legend = TRUE,
title = "",
axis.title = c("MONT.S", "TOT.N"),
term = c("D.PARK", "MONT.S")))
(effects.M.exemplo <- plot_model(M.exemplo,
type = "eff",
show.legend = TRUE,
title = "",
axis.title = c("D.PARK", "TOT.N"),
term = c("D.PARK", "MONT.S")))
if(!require(AICcmodavg)){install.packages("AICcmodavg");library(AICcmodavg)} # Instalando pacotes requeridos
if(!require(bbmle)){install.packages("bbmle");library(bbmle)}
# Lembra do qqPlot para outras distribuicoes?
if(!require(car)){install.packages('car')};library(car)
# Aos curiosos, explore o pacote DHARMa, para diagnostico dos residuos (https://cran.r-project.org/web/packages/DHARMa/vignettes/DHARMa.html)
# DHARMa: simula residuos standardizados que podem ser interpretados como em uma regressao normal
# 1. Simula novos dados observados a partir do modelo ajustado.
# 2. Calcula a função de densidade acumulada dos dados simulados e usa como probabilidades dos dados observados
# 3. Utiliza essa funçao baseada nos dados simulados para calcular novos resíduos
if(!require(DHARMa)){install.packages('DHARMa')};library(DHARMa)
# Para o item 3, gosto muito do pacote sjPlot
if(!require(sjPlot)){install.packages("sjPlot");library(sjPlot)}
if(!require(ggplot2)){install.packages("ggplot2");library(ggplot2)}
if(!require(ggpubr)){install.packages("ggpubr");library(ggpubr)}
# A funcao glm.nb precisa do pacote MASS
if(!require(MASS)){install.packages("MASS");library(MASS)}
# Os modelos (para os mesmos dados)
Mbn1<-glm.nb(TOT.N~OPEN.L+MONT.S+SQ.POLIC+
SQ.SHRUB+SQ.WATRES+L.WAT.C+SQ.LPROAD+
SQ.DWATCOUR+D.PARK,link="log",data=RK) # link="log"
summary(Mbn1)
Mbn2<-glm.nb(TOT.N~OPEN.L+MONT.S+SQ.POLIC+
SQ.SHRUB+SQ.WATRES+L.WAT.C+SQ.LPROAD+D.PARK,link="log",data=RK)
Mbn3<-glm.nb(TOT.N~OPEN.L+MONT.S+
SQ.SHRUB+SQ.WATRES+L.WAT.C+SQ.LPROAD+D.PARK,link="log",data=RK)
Mbn4<-glm.nb(TOT.N~OPEN.L+MONT.S+
SQ.SHRUB+L.WAT.C+SQ.LPROAD+D.PARK,link="log",data=RK)
Mbn5<-glm.nb(TOT.N~OPEN.L+MONT.S+L.WAT.C+SQ.LPROAD+D.PARK,link="log",data=RK)
summary(Mbn5)
Mbn6<-glm.nb(TOT.N~OPEN.L+L.WAT.C+SQ.LPROAD+D.PARK,link="log",data=RK)
drop1(Mbn6, test="Chi")
Mbn7<-glm.nb(TOT.N~OPEN.L+L.WAT.C+D.PARK,link="log",data=RK)
summary(Mbn7)
drop1(Mbn7, test="Chi")
# Veja a tabela AIC (instrucoes acima) - use ICtab
model.sel(Mbn1,Mbn2,Mbn3,Mbn4,Mbn5,Mbn6,Mbn7)
if(!require(bbmle)){install.packages("bbmle");library(bbmle)}
if(!require(MuMIn)){install.packages("MuMIn");library(MuMIn)} # Instalando pacotes requeridos
# Veja a tabela AIC (instrucoes acima) - use ICtab
model.sel(Mbn1,Mbn2,Mbn3,Mbn4,Mbn5,Mbn6,Mbn7)
## or in another way
AIC <- ICtab (Mbn1,Mbn2,Mbn3,Mbn4,Mbn5,Mbn6,Mbn7,base = TRUE, type = c("AICc"), weights = TRUE,
delta = TRUE, sort = TRUE, nobs = 52, k = TRUE)
AIC
# Valide o modelo com a funcao plot(Modelo) ou pelos desvios residuais e discuta (ou ainda pelo pacote DHARMa)
par(mfrow = c(2,2))
plot(Mbn5)
plot(Mbn6)
# Calcular os residuos
simulationOutput <- simulateResiduals(fittedModel = Mbn6, n = 1000)
residuals(simulationOutput)
# Testando dispersao
testDispersion(simulationOutput, type = "PearsonChisq")
# Plot principal para usar
plot(simulationOutput)
simulationOutput7 <- simulateResiduals(fittedModel = Mbn7, n = 1000)
simulationOutput5 <- simulateResiduals(fittedModel = Mbn5, n = 1000)
testDispersion(simulationOutput7, type = "PearsonChisq")
testDispersion(simulationOutput5, type = "PearsonChisq")
# Plot principal para usar
plot(simulationOutput6)
plot(simulationOutput7)
plot(simulationOutput5)
plot(simulationOutput7)
testDispersion(simulationOutput5, type = "PearsonChisq")
plot(simulationOutput5)
plot(simulationOutput7)
plot(simulationOutput5)
# Testando dispersao
testDispersion(simulationOutput6, type = "PearsonChisq")
# Plot principal para usar
plot(simulationOutput6)
# Plot principal para usar
plot(simulationOutput6)
# Calcular os residuos
simulationOutput6 <- simulateResiduals(fittedModel = Mbn6, n = 1000)
simulationOutput7 <- simulateResiduals(fittedModel = Mbn7, n = 1000)
simulationOutput5 <- simulateResiduals(fittedModel = Mbn5, n = 1000)
# Testando dispersao
testDispersion(simulationOutput6, type = "PearsonChisq")
testDispersion(simulationOutput7, type = "PearsonChisq")
# Testando dispersao
testDispersion(simulationOutput6, type = "PearsonChisq")
# Plot principal para usar
plot(simulationOutput6)
plot(simulationOutput7)
plot(simulationOutput5)
drop1(Mbn7, test="Chi")
Mbn8 <- glm.nb(TOT.N~OPEN.L+D.PARK,link="log",data=RK)
summary(Mbn8)
# Veja a tabela AIC (instrucoes acima) - use ICtab
model.sel(Mbn1,Mbn2,Mbn3,Mbn4,Mbn5,Mbn6,Mbn7,Mbn8)
## or in another way
AIC <- ICtab (Mbn1,Mbn2,Mbn3,Mbn4,Mbn5,Mbn6,Mbn7,Mbn8,base = TRUE, type = c("AICc"), weights = TRUE,
delta = TRUE, sort = TRUE, nobs = 52, k = TRUE)
AIC
# Testando dispersao
testDispersion(simulationOutput6, type = "PearsonChisq")
simulationOutput8 <- simulateResiduals(fittedModel = Mbn8, n = 1000)
residuals(simulationOutput8)
testDispersion(simulationOutput8, type = "PearsonChisq")
plot(simulationOutput8)
summary(Mbn8)
## or in another way
AIC <- ICtab (Mbn1,Mbn2,Mbn3,Mbn4,Mbn5,Mbn6,Mbn7,Mbn8,base = TRUE, type = c("AICc"), weights = TRUE,
delta = TRUE, sort = TRUE, nobs = 52, k = TRUE)
AIC
# Veja a tabela AIC (instrucoes acima) - use ICtab
model.sel(Mbn1,Mbn2,Mbn3,Mbn4,Mbn5,Mbn6,Mbn7,Mbn8)
summary(Mbn8)
plot(simulationOutput5)
## or in another way
AIC <- ICtab (Mbn1,Mbn2,Mbn3,Mbn4,Mbn5,Mbn6,Mbn7,Mbn8,base = TRUE, type = c("AICc"), weights = TRUE,
delta = TRUE, sort = TRUE, nobs = 52, k = TRUE)
AIC
plot(simulationOutput5)
plot(simulationOutput8)
# Veja a tabela AIC (instrucoes acima) - use ICtab
model.sel(Mbn1,Mbn2,Mbn3,Mbn4,Mbn5,Mbn6,Mbn7,Mbn8)
plot(Mbn5)
plot(Mbn8)
plot(Mbn5)
plot(Mbn8)
(effects.MONT.S <- plot_model(Mbn5,
type = "eff",
show.legend = FALSE,
title = "",
axis.title = c("MONT.S", "TOT.N"),
term = c("MONT.S")))
(effects.D.PARK <- plot_model(Mbn5,
type = "eff",
show.legend = FALSE,
title = "",
axis.title = c("D.PARK", "TOT.N"),
term = c("D.PARK")))
(effects.OPEN.L <- plot_model(Mbn5,
type = "eff",
show.legend = FALSE,
title = "",
axis.title = c("OPEN.L", "TOT.N"),
term = c("OPEN.L")))
(effects.L.WAT.C <- plot_model(Mbn5,
type = "eff",
show.legend = FALSE,
title = "",
axis.title = c("L.WAT.C", "TOT.N"),
term = c("L.WAT.C")))
(effects.OPEN.L <- plot_model(Mbn5,
type = "eff",
show.legend = FALSE,
title = "",
axis.title = c("OPEN.L", "TOT.N"),
term = c("OPEN.L")))
(effects.SQ.LPROAD <- plot_model(Mbn5,
type = "eff",
show.legend = FALSE,
title = "",
axis.title = c("SQ.LPROAD", "TOT.N"),
term = c("SQ.LPROAD")))
(Fig1.Predicts <- ggarrange(effects.D.PARK, effects.SQ.SHRUB, effects.MONT.S,
labels = c("(a)", "(b)", "(c)"),
ncol = 3, nrow = 1, font.label = list(size = 9, color ="black")))
(Fig2.Predicts <- ggarrange(effects.D.PARK, effects.SQ.LPROAD, effects.MONT.S,
effects.OPEN.L,
effects.MOL.WAT.C,
labels = c("(a)", "(b)", "(c)", "(d)","(e)"),
ncol = 5, nrow = 2, font.label = list(size = 9, color ="black")))
(effects.MOL.WAT.C <- plot_model(Mbn5,
type = "eff",
show.legend = FALSE,
title = "",
axis.title = c("MOL.WAT.C", "TOT.N"),
term = c("MOL.WAT.C")))
(Fig2.Predicts <- ggarrange(effects.D.PARK, effects.SQ.LPROAD, effects.MONT.S,
effects.OPEN.L,
effects.MOL.WAT.C,
labels = c("(a)", "(b)", "(c)", "(d)","(e)"),
ncol = 5, nrow = 2, font.label = list(size = 9, color ="black")))
(Fig2.Predicts <- ggarrange(effects.D.PARK, effects.SQ.LPROAD, effects.MONT.S,
effects.OPEN.L,
effects.MOL.WAT.C,
labels = c("(a)", "(b)", "(c)", "(d)","(e)"),
ncol = 3, nrow = 2, font.label = list(size = 9, color ="black")))
(effects.MOL.WAT.C <- plot_model(Mbn5,
type = "eff",
show.legend = FALSE,
title = "",
axis.title = c("MOL.WAT.C", "TOT.N"),
term = c("MOL.WAT.C")))
(effects.L.WAT.C <- plot_model(Mbn5,
type = "eff",
show.legend = FALSE,
title = "",
axis.title = c("L.WAT.C", "TOT.N"),
term = c("L.WAT.C")))
(Fig2.Predicts <- ggarrange(effects.D.PARK, effects.SQ.LPROAD, effects.MONT.S,
effects.OPEN.L,
effects.L.WAT.C,
labels = c("(a)", "(b)", "(c)", "(d)","(e)"),
ncol = 3, nrow = 2, font.label = list(size = 9, color ="black")))
# Entrar dados de piolho do mar em fazendas de piscicultura na Escocia
Lice <- read.table(file.choose(), header = TRUE, dec = ".")
head(Lice)
Lice <- Lice[-253,]
# Volume varia entre amostras - incluir como offset (vantagens ja discutidas)
Moffset<- glm(Copepod~offset(Volume)+factor(Station), family = poisson, data = Lice)
summary(Moffset)
